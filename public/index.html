<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="shortcut icon" href="assets/icons/home.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Add this at the top of your script
        const API_BASE = window.location.hostname === 'localhost'
            ? 'http://localhost:3001/api'
            : '/api'; // For production, use relative path

        function KanbanBoard() {
            const [board, setBoard] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [currentView, setCurrentView] = useState(() => { return localStorage.getItem('kanban-current-view') || 'board'; });
            const [theme, setTheme] = useState(() => { return localStorage.getItem('kanban-theme') || 'light'; });
            const [showFilters, setShowFilters] = useState(() => { return localStorage.getItem('kanban-show-filters') !== 'false'; });
            const [draggedCard, setDraggedCard] = useState(null);
            const [draggedList, setDraggedList] = useState(null);
            const [dragOverList, setDragOverList] = useState(null);
            const [dragOverCard, setDragOverCard] = useState(null);
            const [showAddList, setShowAddList] = useState(false);
            const [showAddCard, setShowAddCard] = useState(null);
            const [editingCard, setEditingCard] = useState(null);
            const [editingList, setEditingList] = useState(null);
            const [filters, setFilters] = useState({
                search: '',
                priority: 'all',
                dueDate: 'all'
            });
            const [confirmation, setConfirmation] = useState({
                isOpen: false,
                title: '',
                message: '',
                onConfirm: null,
                confirmText: 'Yes',
                cancelText: 'No',
                isDestructive: false
            });

            // Make the update function available globally for the calendar component
            useEffect(() => {
                window.updateBoardAfterCardUpdate = updateCardInBoard;

                // Cleanup on unmount
                return () => {
                    delete window.updateBoardAfterCardUpdate;
                };
            }, []);

            useEffect(() => {
                fetchBoard();
                localStorage.setItem('kanban-current-view', currentView);
            }, [currentView]);

            // Add theme effect
            useEffect(() => {
                localStorage.setItem('kanban-theme', theme);
                document.body.setAttribute('data-theme', theme);
            }, [theme]);

            // Add filter visibility effect
            useEffect(() => {
                localStorage.setItem('kanban-show-filters', showFilters);
            }, [showFilters]);

            const toggleTheme = () => {
                setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
            };

            const toggleFilters = () => {
                setShowFilters(prev => !prev);
            };

            // Helper function to show confirmation
            const showConfirmation = ({ title, message, onConfirm, confirmText = 'Yes', cancelText = 'No', isDestructive = false }) => {
                setConfirmation({
                    isOpen: true,
                    title,
                    message,
                    onConfirm: () => {
                        onConfirm();
                        hideConfirmation();
                    },
                    confirmText,
                    cancelText,
                    isDestructive
                });
            };

            const hideConfirmation = () => {
                setConfirmation({
                    isOpen: false,
                    title: '',
                    message: '',
                    onConfirm: null,
                    confirmText: 'Yes',
                    cancelText: 'No',
                    isDestructive: false
                });
            };

            const fetchBoard = async () => {
                try {
                    const response = await fetch(`${API_BASE}/boards`);
                    const boards = await response.json();

                    if (boards.length > 0) {
                        const boardResponse = await fetch(`${API_BASE}/boards/${boards[0].id}`);
                        const boardData = await boardResponse.json();
                        setBoard(boardData);
                    }
                    setLoading(false);
                } catch (err) {
                    setError('Failed to fetch board data');
                    setLoading(false);
                }
            };

            const addList = async (title) => {
                try {
                    const response = await fetch(`${API_BASE}/lists`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ board_id: board.id, title })
                    });
                    const newList = await response.json();
                    setBoard(prev => ({
                        ...prev,
                        lists: [...prev.lists, newList]
                    }));
                    setShowAddList(false);
                } catch (err) {
                    setError('Failed to add list');
                }
            };

            const updateList = async (listId, title) => {
                try {
                    await fetch(`${API_BASE}/lists/${listId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ title })
                    });

                    setBoard(prev => ({
                        ...prev,
                        lists: prev.lists.map(list =>
                            list.id === listId ? { ...list, title } : list
                        )
                    }));
                    setEditingList(null);
                } catch (err) {
                    setError('Failed to update list');
                }
            };

            const addCard = async (listId, title, description, dueDate, priority) => {
                try {
                    console.log('Adding card with priority:', priority);

                    const response = await fetch(`${API_BASE}/cards`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            list_id: listId,
                            title,
                            description,
                            due_date: dueDate || null,
                            priority
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to add card');
                    }

                    const newCard = await response.json();
                    console.log('Received card from API:', newCard);

                    const cardWithPriority = {
                        ...newCard,
                        priority: newCard.priority || priority,
                        due_date: newCard.due_date || (dueDate || null)
                    };

                    setBoard(prev => ({
                        ...prev,
                        lists: prev.lists.map(list =>
                            list.id === listId
                                ? { ...list, cards: [...list.cards, cardWithPriority] }
                                : list
                        )
                    }));

                    // Close the appropriate modal based on which one is open
                    setShowAddCard(null);

                } catch (err) {
                    console.error('Error adding card:', err);
                    setError('Failed to add card');
                }
            };

            const updateCard = async (cardId, title, description, dueDate, priority) => {
                try {
                    await fetch(`${API_BASE}/cards/${cardId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title,
                            description,
                            due_date: dueDate || null,
                            priority
                        })
                    });

                    setBoard(prev => ({
                        ...prev,
                        lists: prev.lists.map(list => ({
                            ...list,
                            cards: list.cards.map(card =>
                                card.id === cardId
                                    ? { ...card, title, description, due_date: dueDate, priority }
                                    : card
                            )
                        }))
                    }));
                    setEditingCard(null);
                } catch (err) {
                    setError('Failed to update card');
                }
            };

            const updateCardInBoard = (cardId, updates) => {
                setBoard(prev => ({
                    ...prev,
                    lists: prev.lists.map(list => ({
                        ...list,
                        cards: list.cards.map(card =>
                            card.id === cardId
                                ? { ...card, ...updates }
                                : card
                        )
                    }))
                }));
            };

            const deleteCard = async (cardId) => {
                const card = board.lists.flatMap(list => list.cards).find(c => c.id === cardId);

                showConfirmation({
                    title: 'Delete Card',
                    message: `Are you sure you want to delete "${card?.title}"?\n
                    This action cannot be undone.`,
                    confirmText: 'Delete Card',
                    cancelText: 'Cancel',
                    isDestructive: true,
                    onConfirm: async () => {
                        try {
                            await fetch(`${API_BASE}/cards/${cardId}`, {
                                method: 'DELETE'
                            });

                            setBoard(prev => ({
                                ...prev,
                                lists: prev.lists.map(list => ({
                                    ...list,
                                    cards: list.cards.filter(card => card.id !== cardId)
                                }))
                            }));
                            setEditingCard(null);
                        } catch (err) {
                            setError('Failed to delete card');
                        }
                    }
                });
            };

            const deleteList = async (listId) => {
                const list = board.lists.find(l => l.id === listId);
                const cardCount = list?.cards?.length || 0;

                showConfirmation({
                    title: 'Delete List',
                    message: `Are you sure you want to delete "${list?.title}"?${cardCount > 0 ? `\nThis will also delete ${cardCount} card${cardCount === 1 ? '' : 's'}.` : ''}\nThis action cannot be undone.`, confirmText: 'Delete List',
                    cancelText: 'Cancel',
                    isDestructive: true,
                    onConfirm: async () => {
                        try {
                            await fetch(`${API_BASE}/lists/${listId}`, {
                                method: 'DELETE'
                            });

                            setBoard(prev => ({
                                ...prev,
                                lists: prev.lists.filter(list => list.id !== listId)
                            }));
                        } catch (err) {
                            setError('Failed to delete list');
                        }
                    }
                });
            };

            const handleDragStart = (e, card) => {
                e.stopPropagation();
                setDraggedCard(card);
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragEnd = (e) => {
                e.stopPropagation();
                e.target.classList.remove('dragging');
                setDraggedCard(null);
                setDraggedList(null);
                setDragOverList(null);
                setDragOverCard(null);
            };

            const handleListDragStart = (e, list) => {
                setDraggedList(list);
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleListDragEnd = (e) => {
                e.target.classList.remove('dragging');
                setDraggedList(null);
                setDragOverList(null);
            };

            const handleListDragOver = (e, listId) => {
                e.preventDefault();
                e.stopPropagation();

                if (draggedList && draggedList.id !== listId) {
                    e.dataTransfer.dropEffect = 'move';
                    setDragOverList(listId);
                    return;
                }

                if (draggedCard) {
                    e.dataTransfer.dropEffect = 'move';
                    setDragOverList(listId);
                }
            };

            const handleListDragLeave = (e) => {
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    setDragOverList(null);
                }
            };

            const handleCardDragOver = (e, card) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                setDragOverCard(card.id);
            };

            const handleCardDragLeave = (e) => {
                e.stopPropagation();
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    setDragOverCard(null);
                }
            };

            const handleListDrop = async (e, targetListId) => {
                e.preventDefault();
                e.stopPropagation();

                if (draggedList && draggedList.id !== targetListId) {
                    await reorderList(draggedList.id, targetListId);
                    setDragOverList(null);
                    return;
                }

                if (draggedCard && draggedCard.list_id !== targetListId) {
                    await moveCard(draggedCard.id, targetListId, 0);
                }

                setDragOverList(null);
                setDragOverCard(null);
            };

            const handleBoardDragOver = (e) => {
                if (draggedList) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            };

            const handleBoardDrop = (e) => {
                e.preventDefault();
                if (draggedList) {
                    reorderList(draggedList.id, null);
                }
            };

            const reorderList = async (draggedListId, targetListId) => {
                try {
                    const currentLists = [...board.lists];
                    const draggedIndex = currentLists.findIndex(list => list.id === draggedListId);

                    if (draggedIndex === -1) return;

                    let targetIndex;

                    if (targetListId === null) {
                        targetIndex = currentLists.length - 1;
                    } else {
                        targetIndex = currentLists.findIndex(list => list.id === targetListId);
                        if (targetIndex === -1) return;
                    }

                    const [draggedListItem] = currentLists.splice(draggedIndex, 1);
                    currentLists.splice(targetIndex, 0, draggedListItem);

                    const updatedLists = currentLists.map((list, index) => ({
                        ...list,
                        position: index
                    }));

                    setBoard(prev => ({
                        ...prev,
                        lists: updatedLists
                    }));

                    await fetch(`${API_BASE}/lists/${draggedListId}/reorder`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ position: targetIndex })
                    });

                } catch (err) {
                    setError('Failed to reorder list');
                    fetchBoard();
                }
            };

            const handleCardDrop = async (e, targetCard) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOverList(null);
                setDragOverCard(null);

                if (!draggedCard || draggedCard.id === targetCard.id) return;

                const rect = e.currentTarget.getBoundingClientRect();
                const dropY = e.clientY;
                const cardMiddle = rect.top + rect.height / 2;
                const isDroppedAfter = dropY > cardMiddle;

                const targetList = board.lists.find(list => list.id === targetCard.list_id);
                const targetIndex = targetList.cards.findIndex(card => card.id === targetCard.id);
                const newPosition = isDroppedAfter ? targetIndex + 1 : targetIndex;

                await moveCard(draggedCard.id, targetCard.list_id, newPosition);
            };

            const moveCard = async (cardId, targetListId, position) => {
                try {
                    await fetch(`${API_BASE}/cards/${cardId}/move`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            list_id: targetListId,
                            position: position
                        })
                    });

                    setBoard(prev => {
                        const newBoard = { ...prev };
                        let movedCard = null;

                        newBoard.lists = newBoard.lists.map(list => {
                            if (list.cards.some(card => card.id === cardId)) {
                                movedCard = list.cards.find(card => card.id === cardId);
                                return {
                                    ...list,
                                    cards: list.cards.filter(card => card.id !== cardId)
                                };
                            }
                            return list;
                        });

                        newBoard.lists = newBoard.lists.map(list => {
                            if (list.id === targetListId) {
                                const newCards = [...list.cards];
                                const updatedCard = { ...movedCard, list_id: targetListId };
                                newCards.splice(position, 0, updatedCard);
                                return { ...list, cards: newCards };
                            }
                            return list;
                        });

                        return newBoard;
                    });
                } catch (err) {
                    setError('Failed to move card');
                }
            };

            // Filter function for cards
            const filterCards = (cards) => {
                return cards.filter(card => {
                    // Search filter
                    if (filters.search && !card.title.toLowerCase().includes(filters.search.toLowerCase()) &&
                        !card.description?.toLowerCase().includes(filters.search.toLowerCase())) {
                        return false;
                    }

                    // Priority filter
                    if (filters.priority !== 'all' && (card.priority || 'medium') !== filters.priority) {
                        return false;
                    }

                    // Due date filter
                    if (filters.dueDate !== 'all') {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);

                        if (filters.dueDate === 'overdue') {
                            if (!card.due_date) return false;
                            const dueDate = new Date(card.due_date + 'T00:00:00');
                            return dueDate < today;
                        } else if (filters.dueDate === 'today') {
                            if (!card.due_date) return false;
                            const dueDate = new Date(card.due_date + 'T00:00:00');
                            return dueDate.getTime() === today.getTime();
                        } else if (filters.dueDate === 'upcoming') {
                            if (!card.due_date) return false;
                            const dueDate = new Date(card.due_date + 'T00:00:00');
                            const weekFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
                            return dueDate > today && dueDate <= weekFromNow;
                        } else if (filters.dueDate === 'no-date') {
                            return !card.due_date;
                        }
                    }

                    return true;
                });
            };

            // Filter lists for board view
            const filterLists = (lists) => {
                return lists.map(list => ({
                    ...list,
                    cards: filterCards(list.cards)
                }));
            };

            const clearFilters = () => {
                setFilters({
                    search: '',
                    priority: 'all',
                    dueDate: 'all'
                });
            };

            const hasActiveFilters = () => {
                return filters.search !== '' || filters.priority !== 'all' || filters.dueDate !== 'all';
            };

            // Get total filtered cards count
            const getFilteredCardsCount = () => {
                if (!board) return 0;
                const allCards = board.lists.flatMap(list => list.cards);
                return filterCards(allCards).length;
            };

            if (loading) return <div className="loading">Loading your Kanban board...</div>;
            if (error) return <div className="error">{error}</div>;
            if (!board) return <div className="loading">No board found</div>;

            return (
                <div className="app">
                    <div className="header">
                        <h1>Kanban Board</h1>
                    </div>

                    <div className="action-bar">
                        <button className="add-list-button" onClick={() => setShowAddList(true)}>
                            <i className="fas fa-plus"></i>
                            Add List
                        </button>
                        <div className="action-bar-right">
                            <button
                                className={`filter-toggle-button ${showFilters ? 'active' : ''}`}
                                onClick={toggleFilters}
                            >
                                <i className={`fas ${showFilters ? 'fa-filter-circle-xmark' : 'fa-filter'}`}></i>

                            </button>
                            <div className="views">
                                <button
                                    className={currentView === 'board' ? 'active' : ''}
                                    onClick={() => setCurrentView('board')}
                                >
                                    <i className="fa-solid fa-chart-simple fa-flip-both"></i>
                                </button>
                                <button
                                    className={currentView === 'calendar' ? 'active' : ''}
                                    onClick={() => setCurrentView('calendar')}
                                >
                                    <i className="fas fa-calendar"></i>
                                </button>
                            </div>
                            <button
                                className="theme-toggle-button"
                                onClick={toggleTheme}
                                title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
                            >
                                <i className={`fas ${theme === 'light' ? 'fa-moon' : 'fa-sun'}`}></i>
                            </button>
                        </div>
                    </div>

                    {showFilters && (
                        <FilterBar
                            filters={filters}
                            onFiltersChange={setFilters}
                            onClearFilters={clearFilters}
                            hasActiveFilters={hasActiveFilters()}
                            filteredCount={getFilteredCardsCount()}
                            totalCount={board.lists.flatMap(list => list.cards).length}
                        />
                    )}

                    {currentView === 'calendar' && (
                        <CalendarView
                            board={board}
                            filters={filters}
                            onEditCard={(card) => setEditingCard(card)}
                            onAddCard={addCard}
                            onUpdateCard={updateCardInBoard} // Pass the update function
                        />
                    )}

                    {currentView === 'board' && (
                        <div
                            className="board"
                            onDragOver={handleBoardDragOver}
                            onDrop={handleBoardDrop}
                        >
                            {filterLists(board.lists).map(list => (
                                <div
                                    key={list.id}
                                    className={`list ${dragOverList === list.id ? 'drag-over' : ''} ${draggedList && draggedList.id === list.id ? 'dragging' : ''}`}
                                    draggable
                                    onDragStart={(e) => handleListDragStart(e, list)}
                                    onDragEnd={handleListDragEnd}
                                    onDragOver={(e) => handleListDragOver(e, list.id)}
                                    onDragLeave={handleListDragLeave}
                                    onDrop={(e) => handleListDrop(e, list.id)}
                                >
                                    <div className="list-header">
                                        <div className="list-drag-handle">
                                            <i className="fas fa-grip-vertical"></i>
                                        </div>
                                        {editingList === list.id ? (
                                            <EditListTitle
                                                list={list}
                                                onSave={updateList}
                                                onCancel={() => setEditingList(null)}
                                            />
                                        ) : (
                                            <h3
                                                className="list-title"
                                                onDoubleClick={() => setEditingList(list.id)}
                                            >
                                                {list.title}
                                            </h3>
                                        )}
                                        <button
                                            className="delete-button"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                deleteList(list.id);
                                            }}
                                        >
                                            <i className="fas fa-trash"></i>
                                        </button>
                                    </div>

                                    <div className="list-content">
                                        {list.cards.map(card => (
                                            <div
                                                key={card.id}
                                                className={`card ${dragOverCard === card.id ? 'drag-over' : ''} priority-${card.priority || 'medium'}`}
                                                draggable
                                                onDragStart={(e) => handleDragStart(e, card)}
                                                onDragEnd={handleDragEnd}
                                                onDragOver={(e) => handleCardDragOver(e, card)}
                                                onDragLeave={handleCardDragLeave}
                                                onDrop={(e) => handleCardDrop(e, card)}
                                                onClick={(e) => {
                                                    if (!draggedCard) {
                                                        setEditingCard(card);
                                                    }
                                                }}
                                            >
                                                <div className="card-title">{card.title}</div>
                                                {card.description && (
                                                    <div className="card-description">{card.description}</div>
                                                )}
                                                <div className="card-meta">
                                                    {card.due_date && (
                                                        <div className={`card-due-date ${new Date(card.due_date + 'T00:00:00') < new Date() ? 'overdue' : ''}`}>
                                                            <i className="fas fa-calendar"></i>
                                                            {new Date(card.due_date + 'T00:00:00').toLocaleDateString()}
                                                        </div>
                                                    )}
                                                    <div className={`card-priority priority-${card.priority || 'medium'}`}>
                                                        <i className="fas fa-flag"></i>
                                                        {(card.priority || 'medium').charAt(0).toUpperCase() + (card.priority || 'medium').slice(1)}
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>

                                    <button
                                        className="add-button"
                                        onClick={() => setShowAddCard(list.id)}
                                    >
                                        <i className="fas fa-plus"></i>
                                        Add Card
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}

                    {showAddList && (
                        <AddListModal
                            onSave={addList}
                            onClose={() => setShowAddList(false)}
                        />
                    )}

                    {showAddCard && (
                        <AddCardModal
                            onSave={(title, description, dueDate, priority) => addCard(showAddCard, title, description, dueDate, priority)}
                            onClose={() => setShowAddCard(null)}
                        />
                    )}

                    {editingCard && (
                        <EditCardModal
                            card={editingCard}
                            onSave={updateCard}
                            onDelete={deleteCard}
                            onClose={() => setEditingCard(null)}
                        />
                    )}
                    <ConfirmationModal
                        isOpen={confirmation.isOpen}
                        title={confirmation.title}
                        message={confirmation.message}
                        onConfirm={confirmation.onConfirm}
                        onCancel={hideConfirmation}
                        confirmText={confirmation.confirmText}
                        cancelText={confirmation.cancelText}
                        isDestructive={confirmation.isDestructive}
                    />
                </div>
            );
        }

        function FilterBar({ filters, onFiltersChange, onClearFilters, hasActiveFilters, filteredCount, totalCount }) {
            const updateFilter = (key, value) => {
                onFiltersChange(prev => ({
                    ...prev,
                    [key]: value
                }));
            };

            return (
                <div className="filter-bar">
                    <div className="filter-group">
                        <div className="filter-item">
                            <i className="fas fa-search"></i>
                            <input
                                type="text"
                                placeholder="Search cards..."
                                value={filters.search}
                                onChange={(e) => updateFilter('search', e.target.value)}
                                className="filter-input"
                            />
                        </div>

                        <div className="filter-item">
                            <i className="fas fa-flag"></i>
                            <select
                                value={filters.priority}
                                onChange={(e) => updateFilter('priority', e.target.value)}
                                className="filter-select"
                            >
                                <option value="all">All Priorities</option>
                                <option value="low">Low Priority</option>
                                <option value="medium">Medium Priority</option>
                                <option value="high">High Priority</option>
                                <option value="urgent">Urgent Priority</option>
                            </select>
                        </div>

                        <div className="filter-item">
                            <i className="fas fa-calendar"></i>
                            <select
                                value={filters.dueDate}
                                onChange={(e) => updateFilter('dueDate', e.target.value)}
                                className="filter-select"
                            >
                                <option value="all">All Due Dates</option>
                                <option value="overdue">Overdue</option>
                                <option value="today">Due Today</option>
                                <option value="upcoming">Due This Week</option>
                                <option value="no-date">No Due Date</option>
                            </select>
                        </div>

                        <div className="filter-status">
                            {hasActiveFilters && (
                                <div className="filtered-count">
                                    <i className="fas fa-filter"></i>
                                    {filteredCount} of {totalCount} cards
                                </div>
                            )}

                            {hasActiveFilters && (
                                <div className="filter-indicator">
                                    <i className="fas fa-check-circle"></i>
                                    Filters Active
                                </div>
                            )}
                        </div>

                        {hasActiveFilters && (
                            <button
                                className="clear-filters-button"
                                onClick={onClearFilters}
                                title="Clear all filters"
                            >
                                <i className="fas fa-times"></i>
                                Clear Filters
                            </button>
                        )}
                    </div>
                </div>
            );
        }

        function CalendarView({ board, filters, onEditCard, onAddCard, onUpdateCard }) {
            const [currentDate, setCurrentDate] = useState(new Date());
            const [selectedDate, setSelectedDate] = useState(null);
            const [showGoToDate, setShowGoToDate] = useState(false);
            const [goToDateValue, setGoToDateValue] = useState('');
            const [showAddTaskModal, setShowAddTaskModal] = useState(false);
            const [selectedDateForTask, setSelectedDateForTask] = useState(null);
            const [highlightedDate, setHighlightedDate] = useState(null);
            const [draggedCard, setDraggedCard] = useState(null);
            const [dragOverDate, setDragOverDate] = useState(null);
            const [isDragging, setIsDragging] = useState(false);

            // Get all cards with due dates and apply filters
            const getAllCards = () => {
                const allCards = board.lists.flatMap(list =>
                    list.cards.map(card => ({
                        ...card,
                        listName: list.title
                    }))
                );

                // Apply filters
                return allCards.filter(card => {
                    // Search filter
                    if (filters.search && !card.title.toLowerCase().includes(filters.search.toLowerCase()) &&
                        !card.description?.toLowerCase().includes(filters.search.toLowerCase())) {
                        return false;
                    }

                    // Priority filter
                    if (filters.priority !== 'all' && (card.priority || 'medium') !== filters.priority) {
                        return false;
                    }

                    // Due date filter for calendar view
                    if (filters.dueDate !== 'all') {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);

                        if (filters.dueDate === 'overdue') {
                            if (!card.due_date) return false;
                            const dueDate = new Date(card.due_date + 'T00:00:00');
                            return dueDate < today;
                        } else if (filters.dueDate === 'today') {
                            if (!card.due_date) return false;
                            const dueDate = new Date(card.due_date + 'T00:00:00');
                            return dueDate.getTime() === today.getTime();
                        } else if (filters.dueDate === 'upcoming') {
                            if (!card.due_date) return false;
                            const dueDate = new Date(card.due_date + 'T00:00:00');
                            const weekFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
                            return dueDate > today && dueDate <= weekFromNow;
                        } else if (filters.dueDate === 'no-date') {
                            return !card.due_date;
                        }
                    }

                    return true;
                });
            };

            // Get cards for a specific date - now uses filtered cards
            const getCardsForDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const dateStr = `${year}-${month}-${day}`;

                return getAllCards().filter(card => {
                    if (!card.due_date) return false;
                    const cardDateStr = card.due_date.split('T')[0];
                    return cardDateStr === dateStr;
                });
            };

            // Generate calendar days
            const generateCalendarDays = () => {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                const startingDayOfWeek = firstDay.getDay();

                const days = [];

                // Add empty cells for days before the first day of the month
                for (let i = 0; i < startingDayOfWeek; i++) {
                    days.push(null);
                }

                // Add days of the month
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    const cards = getCardsForDate(date);
                    days.push({ date, cards });
                }

                return days;
            };

            const navigateMonth = (direction) => {
                setCurrentDate(prev => {
                    const newDate = new Date(prev);
                    newDate.setMonth(prev.getMonth() + direction);
                    return newDate;
                });
            };

            const updateCardDueDate = async (cardId, newDueDate) => {
                try {
                    const response = await fetch(`${API_BASE}/cards/${cardId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            due_date: newDueDate
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update card');
                    }

                    // Update the board state using the passed function
                    if (onUpdateCard) {
                        onUpdateCard(cardId, { due_date: newDueDate });
                    }
                } catch (error) {
                    console.error('Error updating card date:', error);
                }
            };

            // Calendar card drag handlers
            const handleCardDragStart = (e, card) => {
                e.stopPropagation();
                setDraggedCard(card);
                setIsDragging(true); // Set dragging flag
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', ''); // Required for Firefox

                // Add visual feedback
                e.target.style.opacity = '0.5';
            };

            const handleCardDragEnd = (e) => {
                e.stopPropagation();
                setDraggedCard(null);
                setDragOverDate(null);

                // Reset visual feedback
                e.target.style.opacity = '1';

                // Reset dragging flag after a short delay to prevent click
                setTimeout(() => {
                    setIsDragging(false);
                }, 100);
            };

            const handleDateDragOver = (e, date) => {
                e.preventDefault();
                e.stopPropagation();

                if (draggedCard) {
                    e.dataTransfer.dropEffect = 'move';
                    setDragOverDate(date);
                }
            };

            const handleDateDragLeave = (e) => {
                e.stopPropagation();
                // Only clear drag over if we're actually leaving the date cell
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    setDragOverDate(null);
                }
            };

            const handleDateDrop = async (e, targetDate) => {
                e.preventDefault();
                e.stopPropagation();

                if (!draggedCard) return;

                const year = targetDate.getFullYear();
                const month = String(targetDate.getMonth() + 1).padStart(2, '0');
                const day = String(targetDate.getDate()).padStart(2, '0');
                const newDueDateStr = `${year}-${month}-${day}`;

                // Check if the date is actually different
                const currentDueDateStr = draggedCard.due_date;
                if (currentDueDateStr !== newDueDateStr) {
                    await updateCardDueDate(draggedCard.id, newDueDateStr);
                }

                setDraggedCard(null);
                setDragOverDate(null);
            };

            // Handle card click - prevent when dragging
            const handleCardClick = (e, card) => {
                e.stopPropagation();
                // Only open edit modal if not dragging
                if (!isDragging) {
                    onEditCard(card);
                }
            };

            const goToDate = (dateString) => {
                if (!dateString) return;

                const date = new Date(dateString + 'T00:00:00');
                if (isNaN(date.getTime())) return;

                setCurrentDate(date);
                setHighlightedDate(date); // Set the highlighted date
                setGoToDateValue('');
                setShowGoToDate(false);

                // Clear highlight after 3 seconds
                setTimeout(() => {
                    setHighlightedDate(null);
                }, 3000);
            };

            const goToToday = () => {
                setCurrentDate(new Date());
            };

            const handleDateClick = (date) => {
                setSelectedDate(date);
                setSelectedDateForTask(date);
                setShowAddTaskModal(true);
            };

            const formatDateForInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const isToday = (date) => {
                const today = new Date();
                return date.getFullYear() === today.getFullYear() &&
                    date.getMonth() === today.getMonth() &&
                    date.getDate() === today.getDate();
            };

            const isHighlighted = (date) => {
                if (!highlightedDate) return false;
                return date.getFullYear() === highlightedDate.getFullYear() &&
                    date.getMonth() === highlightedDate.getMonth() &&
                    date.getDate() === highlightedDate.getDate();
            };

            const isDragOver = (date) => {
                if (!dragOverDate) return false;
                return date.getFullYear() === dragOverDate.getFullYear() &&
                    date.getMonth() === dragOverDate.getMonth() &&
                    date.getDate() === dragOverDate.getDate();
            };

            const isOverdue = (date) => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                date.setHours(0, 0, 0, 0);
                return date < today;
            };

            const monthNames = [
                'January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'
            ];

            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Modified calendar rendering to show filter status
            return (
                <div className="calendar-view">
                    <div className="calendar-header">
                        <div className="calendar-nav-left">
                            <button
                                className="calendar-nav-button"
                                onClick={() => navigateMonth(-1)}
                            >
                                <i className="fas fa-chevron-left"></i>
                            </button>
                            <h2 className="calendar-title">
                                {monthNames[currentDate.getMonth()]} {currentDate.getFullYear()}
                                {(filters.search || filters.priority !== 'all' || filters.dueDate !== 'all') && (
                                    <span className="filter-indicator">
                                        <i className="fas fa-filter"></i>
                                        Filtered
                                    </span>
                                )}
                            </h2>
                            <button
                                className="calendar-nav-button"
                                onClick={() => navigateMonth(1)}
                            >
                                <i className="fas fa-chevron-right"></i>
                            </button>
                        </div>

                        <div className="calendar-controls">
                            <button
                                className="calendar-control-button"
                                onClick={goToToday}
                                title="Go to Today"
                            >
                                <i className="fas fa-calendar-day"></i>
                                Today
                            </button>

                            <div className="go-to-date-container">
                                {showGoToDate ? (
                                    <div className="go-to-date-input">
                                        <input
                                            type="date"
                                            value={goToDateValue}
                                            onChange={(e) => setGoToDateValue(e.target.value)}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') {
                                                    goToDate(goToDateValue);
                                                } else if (e.key === 'Escape') {
                                                    setGoToDateValue('');
                                                    setShowGoToDate(false);
                                                }
                                            }}
                                            autoFocus
                                        />
                                        <button
                                            className="go-button"
                                            onClick={() => goToDate(goToDateValue)}
                                        >
                                            Go
                                        </button>
                                        <button
                                            className="cancel-go-button"
                                            onClick={() => {
                                                setGoToDateValue('');
                                                setShowGoToDate(false);
                                            }}
                                        >
                                            <i className="fas fa-times"></i>
                                        </button>
                                    </div>
                                ) : (
                                    <button
                                        className="calendar-control-button"
                                        onClick={() => setShowGoToDate(true)}
                                        title="Go to Specific Date"
                                    >
                                        <i className="fas fa-search"></i>
                                        Go to Date
                                    </button>
                                )}
                            </div>

                            <button
                                className="calendar-control-button add-task-button"
                                onClick={() => {
                                    setSelectedDateForTask(new Date());
                                    setShowAddTaskModal(true);
                                }}
                                title="Add New Task"
                            >
                                <i className="fas fa-plus"></i>
                                Add Task
                            </button>
                        </div>
                    </div>

                    <div className="calendar-grid">
                        {dayNames.map(day => (
                            <div key={day} className="calendar-day-header">
                                {day}
                            </div>
                        ))}

                        {generateCalendarDays().map((dayData, index) => (
                            <div
                                key={index}
                                className={`calendar-day ${dayData
                                    ? `${isToday(dayData.date) ? 'today' : ''} ${isHighlighted(dayData.date) ? 'highlighted' : ''} ${isDragOver(dayData.date) ? 'drag-over' : ''} ${dayData.cards.length > 0 ? 'has-cards' : ''} clickable`
                                    : 'empty'
                                    }`}
                                onClick={() => dayData && handleDateClick(dayData.date)}
                                onDragOver={(e) => dayData && handleDateDragOver(e, dayData.date)}
                                onDragLeave={handleDateDragLeave}
                                onDrop={(e) => dayData && handleDateDrop(e, dayData.date)}
                            >
                                {dayData && (
                                    <>
                                        <div className="calendar-day-number">
                                            {dayData.date.getDate()}
                                        </div>
                                        <div className="calendar-day-cards">
                                            {dayData.cards.map(card => (
                                                <div
                                                    key={card.id}
                                                    className={`calendar-card priority-${card.priority || 'medium'} ${isOverdue(dayData.date) ? 'overdue' : ''
                                                        } ${draggedCard && draggedCard.id === card.id ? 'dragging' : ''}`}
                                                    draggable
                                                    onDragStart={(e) => handleCardDragStart(e, card)}
                                                    onDragEnd={handleCardDragEnd}
                                                    onClick={(e) => handleCardClick(e, card)}
                                                    title={`${card.title} (${card.listName}) - Drag to move to another date`}
                                                >
                                                    <div className="calendar-card-title">{card.title}</div>
                                                    <div className="calendar-card-list">{card.listName}</div>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="calendar-day-add">
                                            <button
                                                className="calendar-add-button"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleDateClick(dayData.date);
                                                }}
                                                title="Add task for this date"
                                            >
                                                <i className="fas fa-plus"></i>
                                            </button>
                                        </div>
                                    </>
                                )}
                            </div>
                        ))}
                    </div>

                    {showAddTaskModal && (
                        <CalendarAddTaskModal
                            selectedDate={selectedDateForTask}
                            lists={board.lists}
                            onSave={onAddCard}
                            onClose={() => {
                                setShowAddTaskModal(false);
                                setSelectedDateForTask(null);
                            }}
                        />
                    )}
                </div>
            );
        }

        function AddListModal({ onSave, onClose }) {
            const [title, setTitle] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (title.trim()) {
                    onSave(title.trim());
                    setTitle('');
                }
            };

            const handleOverlayClick = (e) => {
                if (e.target === e.currentTarget) {
                    onClose();
                }
            };

            return (
                <div className="modal-overlay" onClick={handleOverlayClick}>
                    <div className="modal-content">
                        <h3>Add New List</h3>
                        <form className="modal-form" onSubmit={handleSubmit}>
                            <input
                                type="text"
                                placeholder="List title"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                autoFocus
                                className="modal-input"
                            />
                            <div className="modal-buttons">
                                <button type="submit" className="save-button">
                                    <i className="fa-solid fa-plus"></i>
                                    Add List
                                </button>
                                <button type="button" className="cancel-button" onClick={onClose}>
                                    Cancel
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function EditListTitle({ list, onSave, onCancel }) {
            const [title, setTitle] = useState(list.title);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (title.trim() && title.trim() !== list.title) {
                    onSave(list.id, title.trim());
                } else {
                    onCancel();
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleSubmit(e);
                } else if (e.key === 'Escape') {
                    onCancel();
                }
            };

            const handleBlur = () => {
                if (title.trim() && title.trim() !== list.title) {
                    onSave(list.id, title.trim());
                } else {
                    onCancel();
                }
            };

            return (
                <input
                    type="text"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    onKeyDown={handleKeyDown}
                    onBlur={handleBlur}
                    autoFocus
                    className="list-title-input"
                />
            );
        }

        function AddCardModal({ onSave, onClose }) {
            const [title, setTitle] = useState('');
            const [description, setDescription] = useState('');
            const [dueDate, setDueDate] = useState('');
            const [priority, setPriority] = useState('medium');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (title.trim()) {
                    onSave(title.trim(), description.trim(), dueDate, priority);
                    setTitle('');
                    setDescription('');
                    setDueDate('');
                    setPriority('medium');
                }
            };

            const handleOverlayClick = (e) => {
                if (e.target === e.currentTarget) {
                    onClose();
                }
            };

            return (
                <div className="modal-overlay" onClick={handleOverlayClick}>
                    <div className="modal-content wide">
                        <h3>Add New Card</h3>
                        <form className="modal-form" onSubmit={handleSubmit}>
                            <input
                                type="text"
                                placeholder="Card title"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                autoFocus
                                className="modal-input"
                            />
                            <textarea
                                placeholder="Card description (optional)"
                                value={description}
                                onChange={(e) => setDescription(e.target.value)}
                                className="modal-textarea"
                            />
                            <div className="form-row">
                                <div className="form-group">
                                    <label>Due Date:</label>
                                    <input
                                        type="date"
                                        value={dueDate}
                                        onChange={(e) => setDueDate(e.target.value)}
                                        className="modal-input"
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Priority:</label>
                                    <select
                                        value={priority}
                                        onChange={(e) => setPriority(e.target.value)}
                                        className="modal-select"
                                    >
                                        <option value="low">Low</option>
                                        <option value="medium">Medium</option>
                                        <option value="high">High</option>
                                        <option value="urgent">Urgent</option>
                                    </select>
                                </div>
                            </div>
                            <div className="modal-buttons">
                                <button type="submit" className="save-button">
                                    <i className="fa-solid fa-plus"></i>
                                    Add Card
                                </button>
                                <button type="button" className="cancel-button" onClick={onClose}>
                                    Cancel
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function EditCardModal({ card, onSave, onDelete, onClose }) {
            const [title, setTitle] = useState(card.title);
            const [description, setDescription] = useState(card.description || '');
            const [dueDate, setDueDate] = useState(card.due_date || '');
            const [priority, setPriority] = useState(card.priority || 'medium');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (title.trim()) {
                    onSave(card.id, title.trim(), description.trim(), dueDate, priority);
                }
            };

            const handleDelete = () => {
                onDelete(card.id); // This will now trigger the custom confirmation
            };

            const handleOverlayClick = (e) => {
                if (e.target === e.currentTarget) {
                    onClose();
                }
            };

            return (
                <div className="modal-overlay" onClick={handleOverlayClick}>
                    <div className="modal-content wide">
                        <h3>Edit Card</h3>
                        <form className="modal-form" onSubmit={handleSubmit}>
                            <input
                                type="text"
                                placeholder="Card title"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                className="modal-input"
                            />
                            <textarea
                                placeholder="Card description"
                                value={description}
                                onChange={(e) => setDescription(e.target.value)}
                                className="modal-textarea"
                            />
                            <div className="form-row">
                                <div className="form-group">
                                    <label>Due Date:</label>
                                    <input
                                        type="date"
                                        value={dueDate}
                                        onChange={(e) => setDueDate(e.target.value)}
                                        className="modal-input"
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Priority:</label>
                                    <select
                                        value={priority}
                                        onChange={(e) => setPriority(e.target.value)}
                                        className="modal-select"
                                    >
                                        <option value="low">Low</option>
                                        <option value="medium">Medium</option>
                                        <option value="high">High</option>
                                        <option value="urgent">Urgent</option>
                                    </select>
                                </div>
                            </div>
                            <div className="modal-buttons">
                                <button type="submit" className="save-button">
                                    <i className="fas fa-save"></i>
                                    Save
                                </button>
                                <button type="button" className="delete-button" onClick={handleDelete}>
                                    <i className="fas fa-trash"></i>
                                    Delete
                                </button>
                                <button type="button" className="cancel-button" onClick={onClose}>
                                    Cancel
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function CalendarAddTaskModal({ selectedDate, lists, onSave, onClose }) {
            const [title, setTitle] = useState('');
            const [description, setDescription] = useState('');
            const [selectedList, setSelectedList] = useState(lists[0]?.id || '');
            const [priority, setPriority] = useState('medium');

            const formatDateForDisplay = (date) => {
                return date.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            };

            const formatDateForInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (title.trim() && selectedList) {
                    const dueDate = formatDateForInput(selectedDate);

                    // Call onSave and wait for it to complete
                    await onSave(parseInt(selectedList), title.trim(), description.trim(), dueDate, priority);

                    // Close the modal after successful save
                    onClose();
                }
            };

            const handleOverlayClick = (e) => {
                if (e.target === e.currentTarget) {
                    onClose();
                }
            };

            return (
                <div className="modal-overlay" onClick={handleOverlayClick}>
                    <div className="modal-content wide">
                        <h3>Add Task for {formatDateForDisplay(selectedDate)}</h3>
                        <form className="modal-form" onSubmit={handleSubmit}>
                            <div className="form-group">
                                <label>List:</label>
                                <select
                                    value={selectedList}
                                    onChange={(e) => setSelectedList(e.target.value)}
                                    className="modal-select"
                                    required
                                >
                                    {lists.map(list => (
                                        <option key={list.id} value={list.id}>
                                            {list.title}
                                        </option>
                                    ))}
                                </select>
                            </div>

                            <div className="form-group">
                                <label>Task Title:</label>
                                <input
                                    type="text"
                                    placeholder="Enter task title"
                                    value={title}
                                    onChange={(e) => setTitle(e.target.value)}
                                    autoFocus
                                    className="modal-input"
                                    required
                                />
                            </div>

                            <div className="form-group">
                                <label>Description:</label>
                                <textarea
                                    placeholder="Task description (optional)"
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    className="modal-textarea"
                                />
                            </div>

                            <div className="form-group">
                                <label>Priority:</label>
                                <select
                                    value={priority}
                                    onChange={(e) => setPriority(e.target.value)}
                                    className="modal-select"
                                >
                                    <option value="low">Low</option>
                                    <option value="medium">Medium</option>
                                    <option value="high">High</option>
                                    <option value="urgent">Urgent</option>
                                </select>
                            </div>

                            <div className="modal-buttons">
                                <button type="submit" className="save-button">
                                    <i className="fas fa-plus"></i>
                                    Add Task
                                </button>
                                <button type="button" className="cancel-button" onClick={onClose}>
                                    Cancel
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function ConfirmationModal({ isOpen, title, message, onConfirm, onCancel, confirmText = "Yes", cancelText = "No", isDestructive = false }) {
            if (!isOpen) return null;

            const handleOverlayClick = (e) => {
                if (e.target === e.currentTarget) {
                    onCancel();
                }
            };

            return (
                <div className="modal-overlay" onClick={handleOverlayClick}>
                    <div className="modal-content confirmation-modal">
                        <div className="confirmation-header">
                            <i className={`fas ${isDestructive ? 'fa-exclamation-triangle' : 'fa-question-circle'} confirmation-icon ${isDestructive ? 'destructive' : 'info'}`}></i>
                            <h3>{title}</h3>
                        </div>
                        <div className="confirmation-message">
                            {message}
                        </div>
                        <div className="modal-buttons">
                            <button
                                type="button"
                                className={`confirmation-button ${isDestructive ? 'destructive' : 'primary'}`}
                                onClick={onConfirm}
                                autoFocus
                            >
                                {confirmText}
                            </button>
                            <button
                                type="button"
                                className="cancel-button"
                                onClick={onCancel}
                            >
                                {cancelText}
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<KanbanBoard />, document.getElementById('root'));
    </script>
</body>

</html>